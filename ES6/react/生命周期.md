# 生命周期

**组件的生命周期**

在组件的整个生命周期中，随着该组件的props或者state发生改变，它的DOM表现也将有相应的改变，一个组件就是一个状态机，对于特定的输入，它总会返回一致的输出。

react为每个组件提供了生命周期钩子函数去响应不同的时刻——实例化期、存在期及销毁时

**生命周期方法**

实例化期、存在期、销毁期

**组件的生命周期，包含的主要几种情况：**

组件被实例化的时候、组件属性改变的时候、组件状态被改变的时候、组件被销毁的时候

![](E:\笔记\react\组件的生命周期.png)

## 实例化期

首次调用组件时，有以下方法会被调用（从下到先先后执行）：

**DefaultProps**

用来设置组件默认的props，组件的生命周期只会调用一次。

```javascript
//es7
class Component{
    static defaultProps={}
}
//或者也可以定义在外面es6
Compoent.defaultProps
```

**componentWillMount**

条件：第一次渲染阶段在调用render方法前会被调用

作用：该方法在整个组件生命周期只会被调用一次，所以可利用该方法做一些组件内部的初始化工作，这个是在render方法调用前可修改state的最后一次机会。（不会导致组件重新渲染）

**render**

JSX通过这里，解析成对应的虚拟DOM，渲染成最终的效果

**componentDidMount**

条件：第一次渲染成功过后，组件对应的DOM已经添加到页面后调用

作用：这个阶段表示组件对应的DOM 已经存在，我们可以在这个时候做一些依赖DOM的操作或者其他的一些如请求数据，和第三方库整合的操作。如果嵌套了子组件，子组件会比父组件优先渲染，所以这个时候可以获取子组件相应的DOM（refs、Ajax和一些插件放在这个函数里）

### 关于react中数据获取为什么一定要在componentDidMount里面调用？

constructor()中获取数据的话，如果时间太长，或者出错，组件就渲染不出来，整个页面都没法渲染

constructor()是作组件初始化工作，并不是设计来作加载数据的。

如果使用SSR（服务端渲染），componentWillMount会执行2次，一次在服务端，一次在客户端。而componentDidMount不会。

react16之后采用了Fiber框架，只有componentDidMount生命周期函数是确定被执行一次的，类似ComponentWillMount的生命周期钩子都有可能执行对此，所以不加在这些生命周期中有副作用的操作，比如请求数据之类。

componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他副作用的代码。

## 实例化阶段

**react组件生命周期分了三个阶段，分别是实例化期、存在期、销毁期，在实例化期涉及一些钩子函数去执行相应的操作，首先会执行DefaultProps来初始化状态，之后会调用constructor()方法,，当中主要进行状态的初始化this.state，再之后会调用componentWillMount函数，再render方法之前调用，实例化阶段最后一次修改state的机会，并且不会导致组件重新渲染；再之后触发render方法主要的作用就是生成虚拟DOM，将虚拟DOM 渲染到真实的DOM上，再之后当真实DOM渲染成功之后，会调用componentDidMount，代表真实DOM已经生成可以操作真实DOM并且可以进行一些前后台交互的操作或者第三方的插件的配置也在这里进行。**

## 存在期

 实例化后，当props或者state发生变化时，下面方法依次被调用：

**componentWillReaciveProps(new props):**

条件：当组件获取新属性的时候，第一次渲染不会调用

用处：这个时候可以根据新的属性来修改组件的状态

**shouldComponentUpdate(newProps，newState):**

条件：接收到新属性或者新状态的时候在render前会被调用（除了调用forceUpdate和初始化渲染以外）

用处：该方法让我们有机会决定是否重渲染组件，如果返回false，那么不会重渲染组件，**是react性能优化非常的重要的一环**。组件接受新的state或者props时调用，我们可以设置在此对比前后两个   props和state是否相同。如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法，节省大量性能，尤其是在dom结构复杂的时候。

**componentWillUpdata:**

条件：当组件确定更新，在render之前调用

用处：这个时候可以确定一定会更新组件，可以执行更新前的操作

注意：方法中不能使用setState，setState的操作应该在componentWillRecoiveProps方法中调用

**render**

**componentDidUpdate:**

条件：更新被应用到DOM之后

用处：这个方法在更新真实的DOM成功之后调用，当我们需要访问真实的DOM时，这个方法经常用到                                                             

## 销毁期

销毁阶段，只有一个函数被调用：

componentWillUnmount

每当组件使用完成，这个组件就必须从DOM中销毁，此时该方法就会被调用。当我们在组件中使用了setInterval，那我们就需要在这个方法中调用clearInterval

## react16新的生命周期

### Mounting（加载阶段：涉及4个钩子函数）

**constructor():**

加载的时候调用一次，可以初始化state

**getDerviedStateFormProps(props，state)**

使用方法：**static getDerviedStateFormProps(props，state){return {}}**

组件每次被render的时候，包括在组件构建之后（虚拟dom之后，实际dom挂载之前），每次获取新的props或state之后；每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法

**render()**

react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行

**componentDidMount()**

组件渲染之后调用，只调用一次

### Updating(更新阶段：涉及5个钩子函数)

**getDerviedStateFromProps(props，state) 新**

组件每次被render的时候，包括在组件构建之后（虚拟dom之后，实际dom挂载之前），每次获取新的props或state之后；每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法

**shouldComponentUpdate(nextProps，nextState) 新**

组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render）

**render()**

react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行

**getSnapshotBeforeUpdate(prevProps，prevState)  新**

触发时间：updata发生的时候，在render之后，在组件dom渲染之前；返回一个值，作为componentDidUpdata的三个参数；配合componentDidUpdate，可以覆盖componentWillUpdate的所有算法。

**componentDidUpdate()**

组件加载时不调用，组件更新完成后调用

### Unmounting(卸载阶段：涉及1个钩子函数)

**componentWillUnmount**

组件卸载时触发

### 任何时候都可以用 componentDidCatch(error,info) 新

当子组件中抛出错误后，componentDidCatch就会触发，可以在这个方法里捕获错误。打印错误信息或上报错误信息等操作。

## 变更原因

react16前的生命周期在react v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。

如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做Ajax请求的话，那Ajax将被无谓地多次调用。而且在componentWillMount里发起Ajax，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到

所以除了shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount、componentWillReceriveProps、componentWillUpdate）都被getDervedStateFromProps替代

也就是用一个静态函数getDerivedStateFromProps来取代deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state

![](E:\笔记\react\生命周期.png)