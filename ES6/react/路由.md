# 路由

**单页面应用程序（SPA）**

1、整个应用只有一个完整的页面

2、点击页面的链接不会刷新页面，只会做页面的局部更新

3、数据都需要通过Ajax请求获取，并在前端异步展现

**路由**

react路由是通过一种特殊的链接，点击时会修改浏览器地址栏中的地址，但是浏览器是会忽略掉这次变化所有切面不会被跳转，但是在路由会监听到地址（path）的变化从而根据不同的地址渲染出来不同的组件（component）

**简介**

react Router 4.0它遵循react的设计理念，即万物皆组件。所以RR4只是一堆提供了导航功能的组件（还有若干对象和方法），具有声明式（引入即用），可组合性的特点。

**安装**

RR4本次采用单代码仓库模型架构（monorepo）,这意味着这个仓库里面若干相互独立的包，分为是：

react-router React Router 核心

react-router-dom 用于DOM绑定的react router	适用于网页的

react-router-native	用于react native的react router	适用于native程序的

react-router-redux	react router和redux的集成	适用于所有场景的

react-router-config 静态路由配置的小助手

**引用react-router-dom这个包就行了。当然，如果搭配redux,你还需要使用react-router-redux**

## 安装配置

**cnpm install react-router-dom -D**

### react-router-dom中的基础组件主要分为三类

路由器组件、路由匹配组件、导航组件

## 路由器组件

<Router>	监听地址的变化

**高级路由**

<BrowserRouter>：使用HTML5提供的history API来保持UI和URL的同步

<HashRouter>：使用URL的hash （例如：window.location.hash）来保持UI和URL的同步

<MemoryRouter>：能在内存保存你'URL'的历史记录（并没有对地址栏读写）

<StaticRouter>：从不会改变地址

注：这里<Router>组件下只允许存在一个子元素，如存在多个则会报错

### 路由器匹配组件

<Route>组件主要的作用就是当一个location匹配路由的path时，渲染某些UI

<Route>的属性：

path（string）：exact属性表示路由使用精确匹配模式，非exact模式下'/'匹配所有以'/'开头的路由，一般都会设置，值可以省略。

component：设置要显示的组件，该属性以props的方式传入

### 导航组件

<Link>用来处理a链接类似的功能（它会在页面中生成一个a标签）。

**属性：**

to(string/object)：要跳转的路径或地址

replace（bool）：为true时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为false时，点击链接后将在原有访问历史记录的基础上添加一个新记录。默认为false

<NavLink>会在匹配上当前URL的时候会给已经渲染的元素添加样式参数

属性：activeClassName(String):设置选中样式，默认值为active（需要自己单独设置样式类）

​			activeStyle(object)：当元素被选中时，为此元素该属性值当中设置的样式（行内样式）

#### <Switch>组件

会在匹配第一个匹配的组件，不再往下匹配

**属性：**

activeClassName(string)：设置选中样式，默认值为active（需要自己单独设置样式类）

activeStyle(object)：当元素被选中时，为此元素该属性值当中设置的样式

exact(bool)：为true时，只有当地址完全匹配class和style才会应用

stric(bool)：为true时，在确定位置是否与当前URL匹配时，将考虑位置pathname后的斜线；

​		isActive(func)：判断链是否激活的额外逻辑的功能

<switch>

​	<Route exact path="/" component={Home}/>

​	<Route exact path="/about" component={About}/>

​	<Route exact path="/user" component={User}/>

</switch>

现在，如果处于/about，<Switch>将开始寻找匹配的<Route>.<Route path='/about'/>将匹配，<Switch>将停止寻找匹配并渲染<About>.同样，如果我们处于/michael，<User>将被渲染。

## 路由传值

#### 通过params传参（通配符传参）

优点：简单快捷，并且在刷新页面的时候参数不会丢失。

缺点：只能传字符串，并且如果传的值太多的话，url会变得长而丑陋

如果你想传对象的话，可以用JSON.stringify()想将其转为字符串，然后两另外的页面接收后，用JSON.parse()转回去。

<route path='/path/:name' component={path}/>

<Link to='/path/2'>nnn</Link>

读取参数用：this.props.history.match.params.name

**JS的方式：**

this.props.history.push("/deta/"+id)	//页面跳转

this.props.history.replace("/data/"+id)	//改变重新当前页面渲染

#### 通过query传参

Link组件：var query={

​						pathname:'/path'

​						query:'我是通过query传值'

​					}

​					<Link to={query}>query</Link>

参数获取：this.props.location.query

​					这里的this.props.location.query=='我是通过query传值'

优点：优雅、可传对象

缺点：刷新页面、参数丢失

**JS方式：**

this.props.history.push({pathname:'/query',query:{'type':type,'keyword':value}})

#### 通过state传参

Link组件：var state={

​							pathname:'/state',

​							state:'我是通过state传值'

​					}

​					<Link to={state}>state</Link>

参数获取：this.props.location.state

​					这里的this.props.location.state==='我是通过query传值'

优点：优雅，可传对象

缺点：刷新页面，参数丢失

**JS方式：**

this.props.history.push({pathname:'/state,state:{'type':type,'keyword':value}})